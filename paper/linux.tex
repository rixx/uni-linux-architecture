% This is "sig-alternate.tex" V2.1 April 2013
% This file should be compiled with V2.5 of "sig-alternate.cls" May 2012

\documentclass{sig-alternate-05-2015}

% remove Copyright
\makeatletter
\def\@copyrightspace{\relax}
\makeatother

\begin{document}

\title{Requirements Engineering and Software Architecture in the Linux Kernel}
\subtitle{[Paper for the Requirements Engineering and Software Architecture course at Universität Stuttgart 2015/16]}

\numberofauthors{3}
\author{
    \alignauthor Julian Kuhn\\
        \affaddr{Universität Stuttgart}\\
        \email{mail@example.com}
    \alignauthor Friederike Kunze\\
        \affaddr{Universität Stuttgart}\\
        \email{mail@example.com}
    \alignauthor Oliver R{\"o}hrdanz\\
        \affaddr{Universität Stuttgart}\\
        \email{mail@example.com}
}

\maketitle

\begin{abstract}

This paper tries to detail both the requirements engineering process and the general software architecture of the Linux kernel project.

With regards to the requirements engineering, the paper dicusses the unusual workflow and its results within the development community.
It then continues to contrast this workflow with processes found with external contributors with their own interests in the Linux kernel development and maintenance.

TODO: welche spezifischen Architektur-Teile?

TODO: Zusammenfassung der Resultate

\end{abstract}

% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%
 \begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011074.10011075.10011076</concept_id>
<concept_desc>Software and its engineering~Requirements analysis</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10011007.10011074.10011075.10011077</concept_id>
<concept_desc>Software and its engineering~Software design engineering</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10011007.10010940.10010971</concept_id>
<concept_desc>Software and its engineering~Software system structures</concept_desc>
<concept_significance>300</concept_significance>
</concept>
<concept>
<concept_id>10011007.10011074.10011081.10011082</concept_id>
<concept_desc>Software and its engineering~Software development methods</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~Requirements analysis}
\ccsdesc[500]{Software and its engineering~Software design engineering}
\ccsdesc[300]{Software and its engineering~Software system structures}
\ccsdesc[300]{Software and its engineering~Software development methods}

% End generated code

\printccsdesc{}

\keywords{Linux; Software Architecture; Requirements Engineering}

\section{Introduction}

% intro/relevance
The Linux kernel has, ever since its origins in 1991, changed and influenced the landscapes of software architecture and software development like few other pieces of software before and afterwards.
It has also steadily gained popularity on a variety of platforms ranging from microcontrollers over desktop computers and servers to supercomputers.
The Linux kernel is to be found nearly everywhere, and understanding both its design patterns and development process means understanding one of the most influential software projects in the history of software engineering.

% history
Its architecture aswell as its development process as they exist at the moment are the result of a long history of experimentation of which the blind ends are just as instructional as the provisional result.

The Linux kernel's architecture has been called into question from the very beginning, when Linux creator Linus Torvalds and operating system expert Andrew Tanenbaum had passionate debates about the advantages and disadvantages of microkernels and monolithic kernels.
More recent examples of architectural changes would include the removal of the so-called "big kernel log" in 2011.

In comparison, the development process might seem unchanged because it still relies primarily on mails and mailinglists for communication and development.
But while the communication medium might not have changed significantly, the strict and unyielding development process existing now is a result of many years of experience with an ever-growing project with uncountable amounts of prospective contributors and features.
Preventing feature-bloat and ensuring code quality while still allowing room for new features has always been a goal of the kernel community, and its realization differs from most other software projects, either free or commercial.

% motivation

Sometimes, the structure or the processes of the Linux kernel project might seem strange or only applicable for projects of comparable size and contributor base.
But especially due to its size, history and changes this paper aims to examine the Linux kernel and establish why and how some of its structures were chosen and if they were effective in the way they were intended.

% structure of this paper … irgendwie müssen wirs ja strecken

Because of the amount of contributors, users, code and work put into the Linux kernel project, there have been various papers published, the relevant of which will be discussed in the following section.
Afterwards we will first discuss the requirements engineering process and general workflow within the Linux kernel project and its more commercial branches.
Next we … TODO: was passiert im Software Architecture Teil?
Finally we will sum up our findings and present our conclusions regarding the software architecture and requirements engineering within the Linux kernel.

\section{Related work and sources}

TODO: Stimmt das? Bitte fügt auch eure eigenen Quellen ein

One of our primary sources was the \texttt{Documentation} directory in the Linux repository itself.
On the one hand, it holds valuable and up-to-date documentation of many Kernel modules and is therefore helpful to determine the overall project structure.
On the other hand it also serves as a first point of contact for new developers and contains detailed and beginner-friendly information on the contribution process.

There are multiple secondary sources giving insight into the Linux kernel development, such as "Understanding the Linux kernel"\cite{bovet2005understanding}, "Linux kernel development"\cite{love2010linux}, and "Maintainability of the Linux kernel"\cite{schach2002maintainability}.


\section{Requirements Engineering}

The following sections will discuss the requirements engineering process in the Linux kernel project, and, since the Linux way of requirements engineering is not too well-defined, will also expand upon the contribution process in general.
We will highlight the differences between both of these processes within the Linux kernel community and the software industry and try to present the consequences of the choices the Linux kernel community has made.

\subsection{Requirements engineering process}

The requirements engineering process of the Linux kernel project as it exists now is nearly non-existent beyond the quality requirements which are met by the workflow described below.
This is obviously very unusual: In the software development industry, requirements engineering is a self-evident necessity, as illustrated by the related IEEE tutorial\cite{thayer1997software} and other extensive literature on the subject.
Even other open source projects tend to have some sort of explicit requirements engineering, sometimes by way of a defined API, or community-designed requirements or even requirements imposed by a committee.

The Linux kernel project rejects all of these ways of requirements engineering.
While it does provide a large and mostly stable API externally, the documentation very explicitly states that the internal API is not and does not aim to be stable and thus does not provide requirements in itself.
Linux also is not certified with any kind of interface-related certification such as the POSIX certification group which provides a common standard for operating system interfaces, which is only used as a guideline. POSIX certified systems include OS-X and Solaris.

\subsubsection{Requirements engineering developments}

Historically, Linux development has always rather followed the demands arising from within the development community than some specific requirements.
This started at the very beginning, when Linus Torvalds was mostly focussed on getting the initial kernel to run on his own hardware and work for his own needs, which was then extended by other developers with different hardware and additional needs.

This has not changed fundamentally, as changes are still contributed by community developers following only the requirements placed upon them by the contribution process described below.
The major difference between the beginnings of Linux and the current development community is that as of 2015, more than \(80\%\) of Linux kernel developers are paid for their work on the Linux kernel\cite{corbet2015linux}.
This implies that while the requirements engineering process within the community is still unstructured, there might be less visible requirements engineering processes in external interest groups, directing their developers to work on features of their interest.

\subsubsection{External requirements engineering}

\subsubsection{Comparison with common requirement engineering strategies}

\subsubsection{Requirements engineering results}

\subsection{Contribution process}

\subsubsection{Contribution process developments}
\subsubsection{Quality control}
\subsubsection{Comparison with common contribution processes}
\subsubsection{Contribution process results}

\section{Software Architecture}

\section{Conclusions}

TODO: Conclusions

TODO: Quellen

\bibliographystyle{abbrv}
\bibliography{sigproc}  % sigproc.bib is the name of the Bibliography in this case
%  and remember to run:
% latex bibtex latex latex
% to resolve all references

\balancecolumns{}
\end{document}
